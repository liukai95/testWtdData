预先处理：在F盘中建立文件夹“移动轨迹数据”存放数据newData.csv，建立文件夹test与markovTest，分别存放社团划分相关数据、各方法的测试结果。第一步 对原始数据进行处理，分为实验数据和测试数据，对相邻地点进行合并处理1、使用类NewData先对总数据进行处理，将id少于100的数据去除，然后重新编号。得到245个ID。2、使用类GetData选取从9-22到10-31共40天的数据demo.csv、剩下的数据生成demoTest.csv文件。3、使用类OneSignalData对数据demo.csv处理得到只有一个信号的数据以及出现的AP。生成AP.txt包含357个连接的AP，461个收到的AP，选择截取数据中出现的并且进行连接的地点进行处理。而后进行相邻AP的合并，比如按照两者出现概率大于0.4进行重新编号得到297个AP，生成oneSignalRemove.csv，即只保存连接的AP，并认为该用户此时在这个AP中。4、使用类SameSignalData 得到一个用户在同一时间同时收到的ap，生成sameSignal.txt文件，然后通过同时收到的概率进行合并。特别注意原始数据中有重复的数据，需要进行去重的处理。SameSignal中也要进行处理，有时候同时收到的AP中有重复。第二步 进行相邻AP的合并，选择同时收到的最小概率为0.1至0.91、DoublePointRatesameSignal.txt文件处理，作用是计算两个地点同时被接收到的概率，输出doublePointRate使用类APArea对同时收到的AP进行区域的划分，得到满足条件的能够进行合并的AP，输出doublePointRateResult.txt文件。另外也可输出doublePointRateMaxtir使用克鲁斯科尔算法进行计算，结果相同。2、使用类NewAP对同时收到的AP，以及原来存在的Ap合起来，并重新编号，生成所有的NewAP文件，AP个数分别为148, 180, 233, 297, 338, 357, 359, 359, 360个。第三步是主要部分，分为总数据处理和分段数据处理分段数据处理需要先使用类TimeDivide对oneSignalTwoNextAp.csv文件进行时段划分，划分为n(n=2,3,4,6)段，选择相应的字符数组timeStr，每段占用24/n个小时，输出timeNextAp_i文件，然后每一段和总数据一样进行如下处理。1、使用类OneSignalResult对oneSignalRemove.csv使用重新编号的AP对测试的数据进行修改，并且生成的数据带NEXT_AP_ID，这样方便后面的计算。并且也要对测试数据进行该操作。2、使用类IDTotalMatrix对oneSignalTwoNextAp.csv处理得到所有用户停留在每个AP的概率,结果表示为一个矩阵，即ID个数*AP个数。3、使用类IDDivisionRemove对oneSignalTwoNextAp.csv处理，对总数据按照每个ID移除相同地点后的中间数据，输出每个ID对应的peopleIDNextApRemove_i文件。并组成一个总文件，然后按照时间进行排序，方便后面进行apDivision。对测试数据也要处理，但仅输出输出每个ID对应的peopleIDNextApRemove_i文件即可。4、使用类StateList对数据peopleIDNextApRemove_i处理得到Markov链，即每个ID的移动数据，并且生成idApTime_i文件，为了预测ID在AP停留的时间，数据格式为SAMPLE_TIME,AP_ID,STAY_TIME。5、使用类StateListAddTime对测试数据进行处理，相对于类StateList的改进是增加了时间，为了能够进行社团的修正加入时间这个因素如果不考虑社团修正，则也可使用类StateList生成stateList_i文件。6、使用类APDivision对oneSignalTwoNextApRemoveSort.csv文件处理，得到每个地点被用户访问的数据apVisited_i。7、使用类TimeNumber对apVisited_i处理计算任意两个用户在每个地点相遇的时间以及次数，其中apNumber是得到的相遇次数、apTime是得到的相遇时间。然后需要使用matlab的程序进行相遇的时间以及次数的相加，同时考虑时间和次数，得到概率矩阵。8、使用包getSociety中的类GN进行加权GN算法对概率矩阵得到社团分配结果。总数据的划分结果为RESULTt.txt，以及各分段数据的划分结果RESULTt+n+i.txt，n为划分总段数，i为段编号。第四步 测试部分首先，使osI从1-9取值，可将分段数据注释掉，使用总数据来比较划分区域的平均正确率，测试代码也仅使用“仅Markov预测”的代码，Markov的阶数为一阶与两阶，得到最优的区域划分与二阶Markov对一阶Markov的比较，接下来的测试仅在本划分之下进行。进行测试时将之前的处理代码注释掉，后续的各种测试也可通过注释的方法，各部分程序均放在一个try-catch块中。1、使用类DiscreteMarkov进行Markov链预测，可进行一步和加权多步预测，输入数据为两个Markov链，输出对于每个用户预测的正确率。2、使用包apTime中的类IDApTimeTest进行用户在地点停留时间的预测，输出对于每个用户预测的正确率。在一个划分区域之下，通过改变预测误差进行平均正确率的比较。3、进行一阶Markov预测并且加上社团修正，类DiscreteMarkov中的方法PredictProbSociety调用类SocietyPredictNew进行社团预测，该类需要的数据有任意两点在特定地点相遇的时间、在所有地点相遇的总时间、ID在AP中预测停留的时间、ID在AP中已经停留的时间、社团划分结果、需要预测的带时间的Markov链、所有ID的测试转移数据。仅使用总数据判断社团修正的结果，其中预测停留的时间为调用使用包apTime中的类IDApTime得到的。类SocietyPredict为另一种社团修正的方法，需要使用ID停留在所有地点的概率矩阵替代停留时间。类DiscreteMarkovSplit为分段数据的Markov预测，类SocietyPredict也有一个方法进行分段数据的修正。4、使用包combination中的类CombinationProb、SocietyProb分别进行行为相似组合与社团修正组合，仅使用总数据。通过3与4可得到每个ID的社团修正、相似组合、社团组合三者分别与一阶Markov预测比较。5、使用分段+社团修正+组合预测+二阶Markov的方法进行测试，输出结果进行比较。类Matrix实现了矩阵相乘的功能，类ResultTest中方法的参数为预测的转移概率，返回正确率。6、包markovMethodTest中的类为提出的几种分段Markov比较，使用的参数为转移数据与测试数据。